
sqian003_customproject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000112  00800100  00000af8  00000bac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000af8  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000033  00800212  00800212  00000cbe  2**0
                  ALLOC
  3 .eeprom       0000000f  00810000  00810000  00000cbe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      00000030  00000000  00000000  00000ccd  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000d00  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000130  00000000  00000000  00000d40  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001dfa  00000000  00000000  00000e70  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000a65  00000000  00000000  00002c6a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000fb3  00000000  00000000  000036cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001e4  00000000  00000000  00004684  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000777  00000000  00000000  00004868  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000716  00000000  00000000  00004fdf  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000000c0  00000000  00000000  000056f5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	55 c0       	rjmp	.+170    	; 0xac <__ctors_end>
   2:	00 00       	nop
   4:	70 c0       	rjmp	.+224    	; 0xe6 <__bad_interrupt>
   6:	00 00       	nop
   8:	6e c0       	rjmp	.+220    	; 0xe6 <__bad_interrupt>
   a:	00 00       	nop
   c:	6c c0       	rjmp	.+216    	; 0xe6 <__bad_interrupt>
   e:	00 00       	nop
  10:	6a c0       	rjmp	.+212    	; 0xe6 <__bad_interrupt>
  12:	00 00       	nop
  14:	68 c0       	rjmp	.+208    	; 0xe6 <__bad_interrupt>
  16:	00 00       	nop
  18:	66 c0       	rjmp	.+204    	; 0xe6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	64 c0       	rjmp	.+200    	; 0xe6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	62 c0       	rjmp	.+196    	; 0xe6 <__bad_interrupt>
  22:	00 00       	nop
  24:	60 c0       	rjmp	.+192    	; 0xe6 <__bad_interrupt>
  26:	00 00       	nop
  28:	5e c0       	rjmp	.+188    	; 0xe6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	5c c0       	rjmp	.+184    	; 0xe6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	5a c0       	rjmp	.+180    	; 0xe6 <__bad_interrupt>
  32:	00 00       	nop
  34:	34 c1       	rjmp	.+616    	; 0x29e <__vector_13>
  36:	00 00       	nop
  38:	56 c0       	rjmp	.+172    	; 0xe6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	54 c0       	rjmp	.+168    	; 0xe6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	52 c0       	rjmp	.+164    	; 0xe6 <__bad_interrupt>
  42:	00 00       	nop
  44:	50 c0       	rjmp	.+160    	; 0xe6 <__bad_interrupt>
  46:	00 00       	nop
  48:	4e c0       	rjmp	.+156    	; 0xe6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	4c c0       	rjmp	.+152    	; 0xe6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	4a c0       	rjmp	.+148    	; 0xe6 <__bad_interrupt>
  52:	00 00       	nop
  54:	48 c0       	rjmp	.+144    	; 0xe6 <__bad_interrupt>
  56:	00 00       	nop
  58:	46 c0       	rjmp	.+140    	; 0xe6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	44 c0       	rjmp	.+136    	; 0xe6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	42 c0       	rjmp	.+132    	; 0xe6 <__bad_interrupt>
  62:	00 00       	nop
  64:	40 c0       	rjmp	.+128    	; 0xe6 <__bad_interrupt>
  66:	00 00       	nop
  68:	3e c0       	rjmp	.+124    	; 0xe6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	3c c0       	rjmp	.+120    	; 0xe6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	3a c0       	rjmp	.+116    	; 0xe6 <__bad_interrupt>
  72:	00 00       	nop
  74:	38 c0       	rjmp	.+112    	; 0xe6 <__bad_interrupt>
  76:	00 00       	nop
  78:	36 c0       	rjmp	.+108    	; 0xe6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	34 c0       	rjmp	.+104    	; 0xe6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	32 c0       	rjmp	.+100    	; 0xe6 <__bad_interrupt>
  82:	00 00       	nop
  84:	30 c0       	rjmp	.+96     	; 0xe6 <__bad_interrupt>
  86:	00 00       	nop
  88:	2e c0       	rjmp	.+92     	; 0xe6 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	ed 01       	movw	r28, r26
  8e:	f1 01       	movw	r30, r2
  90:	10 02       	muls	r17, r16
  92:	18 02       	muls	r17, r24
  94:	52 02       	muls	r21, r18
  96:	8c 02       	muls	r24, r28
  98:	a0 02       	muls	r26, r16
  9a:	d2 02       	muls	r29, r18
  9c:	04 03       	mulsu	r16, r20
  9e:	41 03       	mulsu	r20, r17
  a0:	52 03       	mulsu	r21, r18
  a2:	c1 03       	fmuls	r20, r17
  a4:	0b 04       	cpc	r0, r11
  a6:	2d 04       	cpc	r2, r13
  a8:	5c 04       	cpc	r5, r12
  aa:	92 04       	cpc	r9, r2

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	d0 e4       	ldi	r29, 0x40	; 64
  b4:	de bf       	out	0x3e, r29	; 62
  b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_copy_data>:
  b8:	12 e0       	ldi	r17, 0x02	; 2
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b1 e0       	ldi	r27, 0x01	; 1
  be:	e8 ef       	ldi	r30, 0xF8	; 248
  c0:	fa e0       	ldi	r31, 0x0A	; 10
  c2:	00 e0       	ldi	r16, 0x00	; 0
  c4:	0b bf       	out	0x3b, r16	; 59
  c6:	02 c0       	rjmp	.+4      	; 0xcc <__do_copy_data+0x14>
  c8:	07 90       	elpm	r0, Z+
  ca:	0d 92       	st	X+, r0
  cc:	a2 31       	cpi	r26, 0x12	; 18
  ce:	b1 07       	cpc	r27, r17
  d0:	d9 f7       	brne	.-10     	; 0xc8 <__do_copy_data+0x10>

000000d2 <__do_clear_bss>:
  d2:	22 e0       	ldi	r18, 0x02	; 2
  d4:	a2 e1       	ldi	r26, 0x12	; 18
  d6:	b2 e0       	ldi	r27, 0x02	; 2
  d8:	01 c0       	rjmp	.+2      	; 0xdc <.do_clear_bss_start>

000000da <.do_clear_bss_loop>:
  da:	1d 92       	st	X+, r1

000000dc <.do_clear_bss_start>:
  dc:	a5 34       	cpi	r26, 0x45	; 69
  de:	b2 07       	cpc	r27, r18
  e0:	e1 f7       	brne	.-8      	; 0xda <.do_clear_bss_loop>
  e2:	48 d4       	rcall	.+2192   	; 0x974 <main>
  e4:	07 c5       	rjmp	.+2574   	; 0xaf4 <_exit>

000000e6 <__bad_interrupt>:
  e6:	8c cf       	rjmp	.-232    	; 0x0 <__vectors>

000000e8 <GetKeypadKey>:
void TimerOff() {
	TCCR1B 	= 0x00; // bit3bit2bit1bit0=0000: timer off
}

void TimerISR() {
	TimerFlag = 1;
  e8:	8f ee       	ldi	r24, 0xEF	; 239
  ea:	88 b9       	out	0x08, r24	; 8
  ec:	00 00       	nop
  ee:	30 9b       	sbis	0x06, 0	; 6
  f0:	29 c0       	rjmp	.+82     	; 0x144 <GetKeypadKey+0x5c>
  f2:	31 9b       	sbis	0x06, 1	; 6
  f4:	29 c0       	rjmp	.+82     	; 0x148 <GetKeypadKey+0x60>
  f6:	32 9b       	sbis	0x06, 2	; 6
  f8:	29 c0       	rjmp	.+82     	; 0x14c <GetKeypadKey+0x64>
  fa:	33 9b       	sbis	0x06, 3	; 6
  fc:	29 c0       	rjmp	.+82     	; 0x150 <GetKeypadKey+0x68>
  fe:	8f ed       	ldi	r24, 0xDF	; 223
 100:	88 b9       	out	0x08, r24	; 8
 102:	00 00       	nop
 104:	30 9b       	sbis	0x06, 0	; 6
 106:	26 c0       	rjmp	.+76     	; 0x154 <GetKeypadKey+0x6c>
 108:	31 9b       	sbis	0x06, 1	; 6
 10a:	26 c0       	rjmp	.+76     	; 0x158 <GetKeypadKey+0x70>
 10c:	32 9b       	sbis	0x06, 2	; 6
 10e:	26 c0       	rjmp	.+76     	; 0x15c <GetKeypadKey+0x74>
 110:	33 9b       	sbis	0x06, 3	; 6
 112:	26 c0       	rjmp	.+76     	; 0x160 <GetKeypadKey+0x78>
 114:	8f eb       	ldi	r24, 0xBF	; 191
 116:	88 b9       	out	0x08, r24	; 8
 118:	00 00       	nop
 11a:	30 9b       	sbis	0x06, 0	; 6
 11c:	23 c0       	rjmp	.+70     	; 0x164 <GetKeypadKey+0x7c>
 11e:	31 9b       	sbis	0x06, 1	; 6
 120:	23 c0       	rjmp	.+70     	; 0x168 <GetKeypadKey+0x80>
 122:	32 9b       	sbis	0x06, 2	; 6
 124:	23 c0       	rjmp	.+70     	; 0x16c <GetKeypadKey+0x84>
 126:	33 9b       	sbis	0x06, 3	; 6
 128:	23 c0       	rjmp	.+70     	; 0x170 <GetKeypadKey+0x88>
 12a:	8f e7       	ldi	r24, 0x7F	; 127
 12c:	88 b9       	out	0x08, r24	; 8
 12e:	00 00       	nop
 130:	30 9b       	sbis	0x06, 0	; 6
 132:	20 c0       	rjmp	.+64     	; 0x174 <GetKeypadKey+0x8c>
 134:	31 9b       	sbis	0x06, 1	; 6
 136:	20 c0       	rjmp	.+64     	; 0x178 <GetKeypadKey+0x90>
 138:	32 9b       	sbis	0x06, 2	; 6
 13a:	20 c0       	rjmp	.+64     	; 0x17c <GetKeypadKey+0x94>
 13c:	33 9b       	sbis	0x06, 3	; 6
 13e:	20 c0       	rjmp	.+64     	; 0x180 <GetKeypadKey+0x98>
 140:	80 e0       	ldi	r24, 0x00	; 0
 142:	08 95       	ret
 144:	84 e4       	ldi	r24, 0x44	; 68
 146:	08 95       	ret
 148:	83 e2       	ldi	r24, 0x23	; 35
 14a:	08 95       	ret
 14c:	80 e3       	ldi	r24, 0x30	; 48
 14e:	08 95       	ret
 150:	8a e2       	ldi	r24, 0x2A	; 42
 152:	08 95       	ret
 154:	83 e4       	ldi	r24, 0x43	; 67
 156:	08 95       	ret
 158:	89 e3       	ldi	r24, 0x39	; 57
 15a:	08 95       	ret
 15c:	88 e3       	ldi	r24, 0x38	; 56
 15e:	08 95       	ret
 160:	87 e3       	ldi	r24, 0x37	; 55
 162:	08 95       	ret
 164:	82 e4       	ldi	r24, 0x42	; 66
 166:	08 95       	ret
 168:	86 e3       	ldi	r24, 0x36	; 54
 16a:	08 95       	ret
 16c:	85 e3       	ldi	r24, 0x35	; 53
 16e:	08 95       	ret
 170:	84 e3       	ldi	r24, 0x34	; 52
 172:	08 95       	ret
 174:	81 e4       	ldi	r24, 0x41	; 65
 176:	08 95       	ret
 178:	83 e3       	ldi	r24, 0x33	; 51
 17a:	08 95       	ret
 17c:	82 e3       	ldi	r24, 0x32	; 50
 17e:	08 95       	ret
 180:	81 e3       	ldi	r24, 0x31	; 49
 182:	08 95       	ret

00000184 <delay_ms>:
 184:	18 16       	cp	r1, r24
 186:	19 06       	cpc	r1, r25
 188:	5c f0       	brlt	.+22     	; 0x1a0 <delay_ms+0x1c>
 18a:	08 95       	ret
 18c:	00 00       	nop
 18e:	21 50       	subi	r18, 0x01	; 1
 190:	31 09       	sbc	r19, r1
 192:	e1 f7       	brne	.-8      	; 0x18c <delay_ms+0x8>
 194:	4f 5f       	subi	r20, 0xFF	; 255
 196:	5f 4f       	sbci	r21, 0xFF	; 255
 198:	84 17       	cp	r24, r20
 19a:	95 07       	cpc	r25, r21
 19c:	19 f4       	brne	.+6      	; 0x1a4 <delay_ms+0x20>
 19e:	08 95       	ret
 1a0:	40 e0       	ldi	r20, 0x00	; 0
 1a2:	50 e0       	ldi	r21, 0x00	; 0
 1a4:	27 e0       	ldi	r18, 0x07	; 7
 1a6:	33 e0       	ldi	r19, 0x03	; 3
 1a8:	f1 cf       	rjmp	.-30     	; 0x18c <delay_ms+0x8>

000001aa <LCD_WriteCommand>:
 1aa:	2e 98       	cbi	0x05, 6	; 5
 1ac:	8b b9       	out	0x0b, r24	; 11
 1ae:	2f 9a       	sbi	0x05, 7	; 5
 1b0:	00 00       	nop
 1b2:	2f 98       	cbi	0x05, 7	; 5
 1b4:	82 e0       	ldi	r24, 0x02	; 2
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	e5 cf       	rjmp	.-54     	; 0x184 <delay_ms>
 1ba:	08 95       	ret

000001bc <LCD_ClearScreen>:
 1bc:	81 e0       	ldi	r24, 0x01	; 1
 1be:	f5 cf       	rjmp	.-22     	; 0x1aa <LCD_WriteCommand>
 1c0:	08 95       	ret

000001c2 <LCD_Cursor>:
 1c2:	81 31       	cpi	r24, 0x11	; 17
 1c4:	18 f4       	brcc	.+6      	; 0x1cc <LCD_Cursor+0xa>
 1c6:	81 58       	subi	r24, 0x81	; 129
 1c8:	f0 cf       	rjmp	.-32     	; 0x1aa <LCD_WriteCommand>
 1ca:	08 95       	ret
 1cc:	81 55       	subi	r24, 0x51	; 81
 1ce:	ed cf       	rjmp	.-38     	; 0x1aa <LCD_WriteCommand>
 1d0:	08 95       	ret

000001d2 <LCD_init>:
 1d2:	84 e6       	ldi	r24, 0x64	; 100
 1d4:	90 e0       	ldi	r25, 0x00	; 0
 1d6:	d6 df       	rcall	.-84     	; 0x184 <delay_ms>
 1d8:	88 e3       	ldi	r24, 0x38	; 56
 1da:	e7 df       	rcall	.-50     	; 0x1aa <LCD_WriteCommand>
 1dc:	86 e0       	ldi	r24, 0x06	; 6
 1de:	e5 df       	rcall	.-54     	; 0x1aa <LCD_WriteCommand>
 1e0:	8f e0       	ldi	r24, 0x0F	; 15
 1e2:	e3 df       	rcall	.-58     	; 0x1aa <LCD_WriteCommand>
 1e4:	81 e0       	ldi	r24, 0x01	; 1
 1e6:	e1 df       	rcall	.-62     	; 0x1aa <LCD_WriteCommand>
 1e8:	8a e0       	ldi	r24, 0x0A	; 10
 1ea:	90 e0       	ldi	r25, 0x00	; 0
 1ec:	cb cf       	rjmp	.-106    	; 0x184 <delay_ms>
 1ee:	08 95       	ret

000001f0 <LCD_WriteData>:
 1f0:	2e 9a       	sbi	0x05, 6	; 5
 1f2:	8b b9       	out	0x0b, r24	; 11
 1f4:	2f 9a       	sbi	0x05, 7	; 5
 1f6:	00 00       	nop
 1f8:	2f 98       	cbi	0x05, 7	; 5
 1fa:	81 e0       	ldi	r24, 0x01	; 1
 1fc:	90 e0       	ldi	r25, 0x00	; 0
 1fe:	c2 cf       	rjmp	.-124    	; 0x184 <delay_ms>
 200:	08 95       	ret

00000202 <LCD_DisplayString>:
 202:	0f 93       	push	r16
 204:	1f 93       	push	r17
 206:	cf 93       	push	r28
 208:	df 93       	push	r29
 20a:	18 2f       	mov	r17, r24
 20c:	eb 01       	movw	r28, r22
 20e:	d6 df       	rcall	.-84     	; 0x1bc <LCD_ClearScreen>
 210:	88 81       	ld	r24, Y
 212:	88 23       	and	r24, r24
 214:	51 f0       	breq	.+20     	; 0x22a <LCD_DisplayString+0x28>
 216:	01 e0       	ldi	r16, 0x01	; 1
 218:	01 0f       	add	r16, r17
 21a:	81 2f       	mov	r24, r17
 21c:	d2 df       	rcall	.-92     	; 0x1c2 <LCD_Cursor>
 21e:	89 91       	ld	r24, Y+
 220:	e7 df       	rcall	.-50     	; 0x1f0 <LCD_WriteData>
 222:	10 2f       	mov	r17, r16
 224:	88 81       	ld	r24, Y
 226:	81 11       	cpse	r24, r1
 228:	f6 cf       	rjmp	.-20     	; 0x216 <LCD_DisplayString+0x14>
 22a:	df 91       	pop	r29
 22c:	cf 91       	pop	r28
 22e:	1f 91       	pop	r17
 230:	0f 91       	pop	r16
 232:	08 95       	ret

00000234 <TimerSet>:
 234:	60 93 05 01 	sts	0x0105, r22	; 0x800105 <_avr_timer_M>
 238:	70 93 06 01 	sts	0x0106, r23	; 0x800106 <_avr_timer_M+0x1>
 23c:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <_avr_timer_M+0x2>
 240:	90 93 08 01 	sts	0x0108, r25	; 0x800108 <_avr_timer_M+0x3>
 244:	60 93 33 02 	sts	0x0233, r22	; 0x800233 <_avr_timer_cntcurr>
 248:	70 93 34 02 	sts	0x0234, r23	; 0x800234 <_avr_timer_cntcurr+0x1>
 24c:	80 93 35 02 	sts	0x0235, r24	; 0x800235 <_avr_timer_cntcurr+0x2>
 250:	90 93 36 02 	sts	0x0236, r25	; 0x800236 <_avr_timer_cntcurr+0x3>
 254:	08 95       	ret

00000256 <TimerOn>:
 256:	8b e0       	ldi	r24, 0x0B	; 11
 258:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 25c:	8d e7       	ldi	r24, 0x7D	; 125
 25e:	90 e0       	ldi	r25, 0x00	; 0
 260:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 264:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 268:	82 e0       	ldi	r24, 0x02	; 2
 26a:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
 26e:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
 272:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
 276:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <_avr_timer_M>
 27a:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <_avr_timer_M+0x1>
 27e:	a0 91 07 01 	lds	r26, 0x0107	; 0x800107 <_avr_timer_M+0x2>
 282:	b0 91 08 01 	lds	r27, 0x0108	; 0x800108 <_avr_timer_M+0x3>
 286:	80 93 33 02 	sts	0x0233, r24	; 0x800233 <_avr_timer_cntcurr>
 28a:	90 93 34 02 	sts	0x0234, r25	; 0x800234 <_avr_timer_cntcurr+0x1>
 28e:	a0 93 35 02 	sts	0x0235, r26	; 0x800235 <_avr_timer_cntcurr+0x2>
 292:	b0 93 36 02 	sts	0x0236, r27	; 0x800236 <_avr_timer_cntcurr+0x3>
 296:	8f b7       	in	r24, 0x3f	; 63
 298:	80 68       	ori	r24, 0x80	; 128
 29a:	8f bf       	out	0x3f, r24	; 63
 29c:	08 95       	ret

0000029e <__vector_13>:
}

// In our approach, the C programmer does not touch this ISR, but rather TimerISR()
ISR(TIMER1_COMPA_vect)
{
 29e:	1f 92       	push	r1
 2a0:	0f 92       	push	r0
 2a2:	0f b6       	in	r0, 0x3f	; 63
 2a4:	0f 92       	push	r0
 2a6:	11 24       	eor	r1, r1
 2a8:	8f 93       	push	r24
 2aa:	9f 93       	push	r25
 2ac:	af 93       	push	r26
 2ae:	bf 93       	push	r27
	// CPU automatically calls when TCNT0 == OCR0 (every 1 ms per TimerOn settings)
	_avr_timer_cntcurr--; 			// Count down to 0 rather than up to TOP
 2b0:	80 91 33 02 	lds	r24, 0x0233	; 0x800233 <_avr_timer_cntcurr>
 2b4:	90 91 34 02 	lds	r25, 0x0234	; 0x800234 <_avr_timer_cntcurr+0x1>
 2b8:	a0 91 35 02 	lds	r26, 0x0235	; 0x800235 <_avr_timer_cntcurr+0x2>
 2bc:	b0 91 36 02 	lds	r27, 0x0236	; 0x800236 <_avr_timer_cntcurr+0x3>
 2c0:	01 97       	sbiw	r24, 0x01	; 1
 2c2:	a1 09       	sbc	r26, r1
 2c4:	b1 09       	sbc	r27, r1
 2c6:	80 93 33 02 	sts	0x0233, r24	; 0x800233 <_avr_timer_cntcurr>
 2ca:	90 93 34 02 	sts	0x0234, r25	; 0x800234 <_avr_timer_cntcurr+0x1>
 2ce:	a0 93 35 02 	sts	0x0235, r26	; 0x800235 <_avr_timer_cntcurr+0x2>
 2d2:	b0 93 36 02 	sts	0x0236, r27	; 0x800236 <_avr_timer_cntcurr+0x3>
	if (_avr_timer_cntcurr == 0) { 	// results in a more efficient compare
 2d6:	89 2b       	or	r24, r25
 2d8:	8a 2b       	or	r24, r26
 2da:	8b 2b       	or	r24, r27
 2dc:	99 f4       	brne	.+38     	; 0x304 <__vector_13+0x66>
void TimerOff() {
	TCCR1B 	= 0x00; // bit3bit2bit1bit0=0000: timer off
}

void TimerISR() {
	TimerFlag = 1;
 2de:	81 e0       	ldi	r24, 0x01	; 1
 2e0:	80 93 37 02 	sts	0x0237, r24	; 0x800237 <TimerFlag>
{
	// CPU automatically calls when TCNT0 == OCR0 (every 1 ms per TimerOn settings)
	_avr_timer_cntcurr--; 			// Count down to 0 rather than up to TOP
	if (_avr_timer_cntcurr == 0) { 	// results in a more efficient compare
		TimerISR(); 				// Call the ISR that the user uses
		_avr_timer_cntcurr = _avr_timer_M;
 2e4:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <_avr_timer_M>
 2e8:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <_avr_timer_M+0x1>
 2ec:	a0 91 07 01 	lds	r26, 0x0107	; 0x800107 <_avr_timer_M+0x2>
 2f0:	b0 91 08 01 	lds	r27, 0x0108	; 0x800108 <_avr_timer_M+0x3>
 2f4:	80 93 33 02 	sts	0x0233, r24	; 0x800233 <_avr_timer_cntcurr>
 2f8:	90 93 34 02 	sts	0x0234, r25	; 0x800234 <_avr_timer_cntcurr+0x1>
 2fc:	a0 93 35 02 	sts	0x0235, r26	; 0x800235 <_avr_timer_cntcurr+0x2>
 300:	b0 93 36 02 	sts	0x0236, r27	; 0x800236 <_avr_timer_cntcurr+0x3>
	}
}
 304:	bf 91       	pop	r27
 306:	af 91       	pop	r26
 308:	9f 91       	pop	r25
 30a:	8f 91       	pop	r24
 30c:	0f 90       	pop	r0
 30e:	0f be       	out	0x3f, r0	; 63
 310:	0f 90       	pop	r0
 312:	1f 90       	pop	r1
 314:	18 95       	reti

00000316 <A2D_init>:
unsigned char ram_pass[5] = {0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char ram_pin[4] = {0x00, 0x00, 0x00, 0x00};
	
// joystick
void A2D_init() {
	ADCSRA |= (1 << ADEN) | (1 << ADSC) | (1 << ADATE);
 316:	ea e7       	ldi	r30, 0x7A	; 122
 318:	f0 e0       	ldi	r31, 0x00	; 0
 31a:	80 81       	ld	r24, Z
 31c:	80 6e       	ori	r24, 0xE0	; 224
 31e:	80 83       	st	Z, r24
 320:	08 95       	ret

00000322 <Set_A2D_Pin>:
}

void Set_A2D_Pin(unsigned char pinNum)
{
	ADMUX = (pinNum <= 0x07) ? pinNum : ADMUX;
 322:	88 30       	cpi	r24, 0x08	; 8
 324:	60 f0       	brcs	.+24     	; 0x33e <Set_A2D_Pin+0x1c>
 326:	ec e7       	ldi	r30, 0x7C	; 124
 328:	f0 e0       	ldi	r31, 0x00	; 0
 32a:	80 81       	ld	r24, Z
 32c:	80 83       	st	Z, r24
void A2D_init() {
	ADCSRA |= (1 << ADEN) | (1 << ADSC) | (1 << ADATE);
}

void Set_A2D_Pin(unsigned char pinNum)
{
 32e:	8f e0       	ldi	r24, 0x0F	; 15
	ADMUX = (pinNum <= 0x07) ? pinNum : ADMUX;
	static unsigned char h = 0;
	for(h = 0; h < 15; ++h){asm("nop");}
 330:	00 00       	nop
 332:	81 50       	subi	r24, 0x01	; 1
 334:	e9 f7       	brne	.-6      	; 0x330 <Set_A2D_Pin+0xe>
 336:	8f e0       	ldi	r24, 0x0F	; 15
 338:	80 93 12 02 	sts	0x0212, r24	; 0x800212 <__data_end>
}
 33c:	08 95       	ret
	ADCSRA |= (1 << ADEN) | (1 << ADSC) | (1 << ADATE);
}

void Set_A2D_Pin(unsigned char pinNum)
{
	ADMUX = (pinNum <= 0x07) ? pinNum : ADMUX;
 33e:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
 342:	f5 cf       	rjmp	.-22     	; 0x32e <Set_A2D_Pin+0xc>

00000344 <A2D_convert>:
	for(h = 0; h < 15; ++h){asm("nop");}
}

void A2D_convert()
{
	ADCSRA |=(1<<ADSC); // begin converting
 344:	ea e7       	ldi	r30, 0x7A	; 122
 346:	f0 e0       	ldi	r31, 0x00	; 0
 348:	80 81       	ld	r24, Z
 34a:	80 64       	ori	r24, 0x40	; 64
 34c:	80 83       	st	Z, r24
	while ( !(ADCSRA & (1<<ADIF))); // wait to make sure all pins are read
 34e:	80 81       	ld	r24, Z
 350:	84 ff       	sbrs	r24, 4
 352:	fd cf       	rjmp	.-6      	; 0x34e <A2D_convert+0xa>
}
 354:	08 95       	ret

00000356 <transferdata>:

// shift register
void transferdata(unsigned char data){
	unsigned char inp = data;
	
	SET_BIT(SHIFT_REG, 3);	// SRCLR
 356:	2b 9a       	sbi	0x05, 3	; 5
	CLR_BIT(SHIFT_REG, 1);	// RCLK
 358:	29 98       	cbi	0x05, 1	; 5
	
	for(m= 0; m < 8; m++){
 35a:	10 92 26 02 	sts	0x0226, r1	; 0x800226 <m>
		CLR_BIT(SHIFT_REG, 2);  // SRCLK
		inp = GET_BIT(data, m);
		if(inp) {
 35e:	41 e0       	ldi	r20, 0x01	; 1
 360:	50 e0       	ldi	r21, 0x00	; 0
	
	SET_BIT(SHIFT_REG, 3);	// SRCLR
	CLR_BIT(SHIFT_REG, 1);	// RCLK
	
	for(m= 0; m < 8; m++){
		CLR_BIT(SHIFT_REG, 2);  // SRCLK
 362:	2a 98       	cbi	0x05, 2	; 5
		inp = GET_BIT(data, m);
		if(inp) {
 364:	9a 01       	movw	r18, r20
 366:	00 90 26 02 	lds	r0, 0x0226	; 0x800226 <m>
 36a:	02 c0       	rjmp	.+4      	; 0x370 <transferdata+0x1a>
 36c:	22 0f       	add	r18, r18
 36e:	33 1f       	adc	r19, r19
 370:	0a 94       	dec	r0
 372:	e2 f7       	brpl	.-8      	; 0x36c <transferdata+0x16>
 374:	28 23       	and	r18, r24
 376:	11 f0       	breq	.+4      	; 0x37c <transferdata+0x26>
			SET_BIT(SHIFT_REG, 0);	// SER
 378:	28 9a       	sbi	0x05, 0	; 5
 37a:	01 c0       	rjmp	.+2      	; 0x37e <transferdata+0x28>
		}
		else {
			CLR_BIT(SHIFT_REG, 0); // SER
 37c:	28 98       	cbi	0x05, 0	; 5
		}
		SET_BIT(SHIFT_REG, 2);	// SRCLK
 37e:	2a 9a       	sbi	0x05, 2	; 5
	unsigned char inp = data;
	
	SET_BIT(SHIFT_REG, 3);	// SRCLR
	CLR_BIT(SHIFT_REG, 1);	// RCLK
	
	for(m= 0; m < 8; m++){
 380:	90 91 26 02 	lds	r25, 0x0226	; 0x800226 <m>
 384:	9f 5f       	subi	r25, 0xFF	; 255
 386:	90 93 26 02 	sts	0x0226, r25	; 0x800226 <m>
 38a:	98 30       	cpi	r25, 0x08	; 8
 38c:	50 f3       	brcs	.-44     	; 0x362 <transferdata+0xc>
		else {
			CLR_BIT(SHIFT_REG, 0); // SER
		}
		SET_BIT(SHIFT_REG, 2);	// SRCLK
	}
	SET_BIT(SHIFT_REG, 1);	// RCLK
 38e:	29 9a       	sbi	0x05, 1	; 5
 390:	08 95       	ret

00000392 <customchar>:
}

// custom character
void customchar (unsigned char *Pattern, const char loc)
{
 392:	0f 93       	push	r16
 394:	1f 93       	push	r17
 396:	cf 93       	push	r28
 398:	df 93       	push	r29
 39a:	8c 01       	movw	r16, r24
	LCD_WriteCommand(0x40+(loc*8)); // sending address
 39c:	86 2f       	mov	r24, r22
 39e:	88 0f       	add	r24, r24
 3a0:	88 0f       	add	r24, r24
 3a2:	88 0f       	add	r24, r24
 3a4:	80 5c       	subi	r24, 0xC0	; 192
 3a6:	01 df       	rcall	.-510    	; 0x1aa <LCD_WriteCommand>
 3a8:	e8 01       	movw	r28, r16
 3aa:	08 5f       	subi	r16, 0xF8	; 248
 3ac:	1f 4f       	sbci	r17, 0xFF	; 255
	for (int i=0; i<8; i++) {
		LCD_WriteData(Pattern[i]); // pass pattern bytes to LCD
 3ae:	89 91       	ld	r24, Y+
 3b0:	1f df       	rcall	.-450    	; 0x1f0 <LCD_WriteData>

// custom character
void customchar (unsigned char *Pattern, const char loc)
{
	LCD_WriteCommand(0x40+(loc*8)); // sending address
	for (int i=0; i<8; i++) {
 3b2:	c0 17       	cp	r28, r16
 3b4:	d1 07       	cpc	r29, r17
 3b6:	d9 f7       	brne	.-10     	; 0x3ae <customchar+0x1c>
		LCD_WriteData(Pattern[i]); // pass pattern bytes to LCD
	}
}
 3b8:	df 91       	pop	r29
 3ba:	cf 91       	pop	r28
 3bc:	1f 91       	pop	r17
 3be:	0f 91       	pop	r16
 3c0:	08 95       	ret

000003c2 <createAcc>:

// create account
void createAcc() {
	switch(acc_state) {
 3c2:	e0 91 3b 02 	lds	r30, 0x023B	; 0x80023b <acc_state>
 3c6:	8e 2f       	mov	r24, r30
 3c8:	90 e0       	ldi	r25, 0x00	; 0
 3ca:	89 30       	cpi	r24, 0x09	; 9
 3cc:	91 05       	cpc	r25, r1
 3ce:	08 f0       	brcs	.+2      	; 0x3d2 <createAcc+0x10>
 3d0:	4a c1       	rjmp	.+660    	; 0x666 <__LOCK_REGION_LENGTH__+0x266>
 3d2:	fc 01       	movw	r30, r24
 3d4:	ea 5b       	subi	r30, 0xBA	; 186
 3d6:	ff 4f       	sbci	r31, 0xFF	; 255
 3d8:	5c c3       	rjmp	.+1720   	; 0xa92 <__tablejump2__>
		case start:
		acc_state = createUser;
 3da:	81 e0       	ldi	r24, 0x01	; 1
 3dc:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
		break;
		
		case createUser:
		x = GetKeypadKey();
 3e0:	08 95       	ret
 3e2:	82 de       	rcall	.-764    	; 0xe8 <GetKeypadKey>
 3e4:	80 93 39 02 	sts	0x0239, r24	; 0x800239 <x>
		if (j >= 4) {
 3e8:	90 91 28 02 	lds	r25, 0x0228	; 0x800228 <j>
 3ec:	94 30       	cpi	r25, 0x04	; 4
 3ee:	20 f0       	brcs	.+8      	; 0x3f8 <createAcc+0x36>
			acc_state = userCreated;
 3f0:	82 e0       	ldi	r24, 0x02	; 2
 3f2:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
			break;
 3f6:	08 95       	ret
		}
		else if (x != '\0') {
 3f8:	88 23       	and	r24, r24
			LCD_WriteData(x);
 3fa:	71 f0       	breq	.+28     	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
 3fc:	f9 de       	rcall	.-526    	; 0x1f0 <LCD_WriteData>
			eeprom_write_byte(&eeprom_user[j], x);
 3fe:	80 91 28 02 	lds	r24, 0x0228	; 0x800228 <j>
 402:	90 e0       	ldi	r25, 0x00	; 0
 404:	60 91 39 02 	lds	r22, 0x0239	; 0x800239 <x>
 408:	87 5f       	subi	r24, 0xF7	; 247
 40a:	9f 4f       	sbci	r25, 0xFF	; 255
 40c:	65 d3       	rcall	.+1738   	; 0xad8 <eeprom_write_byte>
			j++;
 40e:	80 91 28 02 	lds	r24, 0x0228	; 0x800228 <j>
 412:	8f 5f       	subi	r24, 0xFF	; 255
 414:	80 93 28 02 	sts	0x0228, r24	; 0x800228 <j>
		}
		acc_state = createUser;
 418:	81 e0       	ldi	r24, 0x01	; 1
 41a:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
		break;
		
		case userCreated:
		eeprom_write_byte(&eeprom_user[4], 1);
 41e:	08 95       	ret
 420:	61 e0       	ldi	r22, 0x01	; 1
 422:	8d e0       	ldi	r24, 0x0D	; 13
 424:	90 e0       	ldi	r25, 0x00	; 0
 426:	58 d3       	rcall	.+1712   	; 0xad8 <eeprom_write_byte>
		acc_state = createPw;
 428:	83 e0       	ldi	r24, 0x03	; 3
 42a:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
		break;
		
		case createPw:
		LCD_DisplayString(1, "Create Password:");
 42e:	08 95       	ret
 430:	61 e1       	ldi	r22, 0x11	; 17
 432:	71 e0       	ldi	r23, 0x01	; 1
 434:	81 e0       	ldi	r24, 0x01	; 1
		y = GetKeypadKey();
 436:	e5 de       	rcall	.-566    	; 0x202 <LCD_DisplayString>
 438:	57 de       	rcall	.-850    	; 0xe8 <GetKeypadKey>
 43a:	80 93 40 02 	sts	0x0240, r24	; 0x800240 <y>
		if (k >= 4) {
 43e:	90 91 27 02 	lds	r25, 0x0227	; 0x800227 <k>
			LCD_DisplayString(1, "Password Created");
 442:	94 30       	cpi	r25, 0x04	; 4
 444:	a8 f0       	brcs	.+42     	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
 446:	62 e2       	ldi	r22, 0x22	; 34
 448:	71 e0       	ldi	r23, 0x01	; 1
 44a:	81 e0       	ldi	r24, 0x01	; 1
			transferdata(0xF8);
 44c:	da de       	rcall	.-588    	; 0x202 <LCD_DisplayString>
 44e:	88 ef       	ldi	r24, 0xF8	; 248
 450:	82 df       	rcall	.-252    	; 0x356 <transferdata>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 452:	2f eb       	ldi	r18, 0xBF	; 191
 454:	86 ec       	ldi	r24, 0xC6	; 198
 456:	9d e2       	ldi	r25, 0x2D	; 45
 458:	21 50       	subi	r18, 0x01	; 1
 45a:	80 40       	sbci	r24, 0x00	; 0
 45c:	90 40       	sbci	r25, 0x00	; 0
 45e:	e1 f7       	brne	.-8      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
 460:	00 c0       	rjmp	.+0      	; 0x462 <__LOCK_REGION_LENGTH__+0x62>
			_delay_ms(15000);
			transferdata(0x00);
 462:	00 00       	nop
 464:	80 e0       	ldi	r24, 0x00	; 0
			acc_state = createPin;
 466:	77 df       	rcall	.-274    	; 0x356 <transferdata>
 468:	84 e0       	ldi	r24, 0x04	; 4
			break;
 46a:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
		}
		else if (y != '\0') {
 46e:	08 95       	ret
 470:	88 23       	and	r24, r24
			LCD_Cursor(17+k);
 472:	09 f4       	brne	.+2      	; 0x476 <__LOCK_REGION_LENGTH__+0x76>
 474:	f8 c0       	rjmp	.+496    	; 0x666 <__LOCK_REGION_LENGTH__+0x266>
 476:	81 e1       	ldi	r24, 0x11	; 17
			LCD_WriteData(y);
 478:	89 0f       	add	r24, r25
 47a:	a3 de       	rcall	.-698    	; 0x1c2 <LCD_Cursor>
 47c:	80 91 40 02 	lds	r24, 0x0240	; 0x800240 <y>
			eeprom_write_byte(&eeprom_pass[k], y);
 480:	b7 de       	rcall	.-658    	; 0x1f0 <LCD_WriteData>
 482:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <k>
 486:	90 e0       	ldi	r25, 0x00	; 0
 488:	60 91 40 02 	lds	r22, 0x0240	; 0x800240 <y>
 48c:	8c 5f       	subi	r24, 0xFC	; 252
 48e:	9f 4f       	sbci	r25, 0xFF	; 255
			k++;
 490:	23 d3       	rcall	.+1606   	; 0xad8 <eeprom_write_byte>
 492:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <k>
 496:	8f 5f       	subi	r24, 0xFF	; 255
			acc_state = createPw;
 498:	80 93 27 02 	sts	0x0227, r24	; 0x800227 <k>
 49c:	83 e0       	ldi	r24, 0x03	; 3
 49e:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
		}
		break;
		
		case createPin:
		LCD_DisplayString(1, "Create PIN:");
 4a2:	08 95       	ret
 4a4:	63 e3       	ldi	r22, 0x33	; 51
		w = GetKeypadKey();
 4a6:	71 e0       	ldi	r23, 0x01	; 1
 4a8:	81 e0       	ldi	r24, 0x01	; 1
 4aa:	ab de       	rcall	.-682    	; 0x202 <LCD_DisplayString>
 4ac:	1d de       	rcall	.-966    	; 0xe8 <GetKeypadKey>
		if (h >= 3) {
 4ae:	80 93 3c 02 	sts	0x023C, r24	; 0x80023c <w>
 4b2:	90 91 29 02 	lds	r25, 0x0229	; 0x800229 <h>
			LCD_DisplayString(1, "Pin Created");
 4b6:	93 30       	cpi	r25, 0x03	; 3
 4b8:	a8 f0       	brcs	.+42     	; 0x4e4 <__LOCK_REGION_LENGTH__+0xe4>
 4ba:	6f e3       	ldi	r22, 0x3F	; 63
 4bc:	71 e0       	ldi	r23, 0x01	; 1
			transferdata(0xF8);
 4be:	81 e0       	ldi	r24, 0x01	; 1
 4c0:	a0 de       	rcall	.-704    	; 0x202 <LCD_DisplayString>
 4c2:	88 ef       	ldi	r24, 0xF8	; 248
 4c4:	48 df       	rcall	.-368    	; 0x356 <transferdata>
 4c6:	2f eb       	ldi	r18, 0xBF	; 191
 4c8:	86 ec       	ldi	r24, 0xC6	; 198
 4ca:	9d e2       	ldi	r25, 0x2D	; 45
 4cc:	21 50       	subi	r18, 0x01	; 1
 4ce:	80 40       	sbci	r24, 0x00	; 0
 4d0:	90 40       	sbci	r25, 0x00	; 0
			_delay_ms(15000);
			transferdata(0x00);
 4d2:	e1 f7       	brne	.-8      	; 0x4cc <__LOCK_REGION_LENGTH__+0xcc>
 4d4:	00 c0       	rjmp	.+0      	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
 4d6:	00 00       	nop
			acc_state = verifybotmsg;
 4d8:	80 e0       	ldi	r24, 0x00	; 0
 4da:	3d df       	rcall	.-390    	; 0x356 <transferdata>
			break;
 4dc:	85 e0       	ldi	r24, 0x05	; 5
		}
		else if (w != '\0') {
 4de:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
 4e2:	08 95       	ret
			LCD_Cursor(17+h);
 4e4:	88 23       	and	r24, r24
 4e6:	09 f4       	brne	.+2      	; 0x4ea <__LOCK_REGION_LENGTH__+0xea>
 4e8:	be c0       	rjmp	.+380    	; 0x666 <__LOCK_REGION_LENGTH__+0x266>
 4ea:	81 e1       	ldi	r24, 0x11	; 17
			LCD_WriteData(w);
 4ec:	89 0f       	add	r24, r25
 4ee:	69 de       	rcall	.-814    	; 0x1c2 <LCD_Cursor>
 4f0:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <w>
			eeprom_write_byte(&eeprom_pin[h], w);
 4f4:	7d de       	rcall	.-774    	; 0x1f0 <LCD_WriteData>
 4f6:	80 91 29 02 	lds	r24, 0x0229	; 0x800229 <h>
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	60 91 3c 02 	lds	r22, 0x023C	; 0x80023c <w>
 500:	80 50       	subi	r24, 0x00	; 0
 502:	90 40       	sbci	r25, 0x00	; 0
			h++;
 504:	e9 d2       	rcall	.+1490   	; 0xad8 <eeprom_write_byte>
 506:	80 91 29 02 	lds	r24, 0x0229	; 0x800229 <h>
 50a:	8f 5f       	subi	r24, 0xFF	; 255
			acc_state = createPin;
 50c:	80 93 29 02 	sts	0x0229, r24	; 0x800229 <h>
 510:	84 e0       	ldi	r24, 0x04	; 4
		}
		break;
		
		case verifybotmsg:
		LCD_DisplayString(1, "Verify human");
 512:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
 516:	08 95       	ret
 518:	6b e4       	ldi	r22, 0x4B	; 75
 51a:	71 e0       	ldi	r23, 0x01	; 1
 51c:	81 e0       	ldi	r24, 0x01	; 1
 51e:	71 de       	rcall	.-798    	; 0x202 <LCD_DisplayString>
 520:	2f eb       	ldi	r18, 0xBF	; 191
 522:	86 ec       	ldi	r24, 0xC6	; 198
 524:	9d e2       	ldi	r25, 0x2D	; 45
 526:	21 50       	subi	r18, 0x01	; 1
 528:	80 40       	sbci	r24, 0x00	; 0
		_delay_ms(15000);
		LCD_DisplayString(1, "U,D,R,U,L,R");
 52a:	90 40       	sbci	r25, 0x00	; 0
 52c:	e1 f7       	brne	.-8      	; 0x526 <__LOCK_REGION_LENGTH__+0x126>
 52e:	00 c0       	rjmp	.+0      	; 0x530 <__LOCK_REGION_LENGTH__+0x130>
 530:	00 00       	nop
 532:	68 e5       	ldi	r22, 0x58	; 88
		acc_state = jsUD;
 534:	71 e0       	ldi	r23, 0x01	; 1
 536:	81 e0       	ldi	r24, 0x01	; 1
 538:	64 de       	rcall	.-824    	; 0x202 <LCD_DisplayString>
		
		case jsUD:
		z = GetKeypadKey();
 53a:	86 e0       	ldi	r24, 0x06	; 6
 53c:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
		if (z != '#') {
 540:	d3 dd       	rcall	.-1114   	; 0xe8 <GetKeypadKey>
 542:	80 93 3d 02 	sts	0x023D, r24	; 0x80023d <z>
			Set_A2D_Pin(0x00);
 546:	83 32       	cpi	r24, 0x23	; 35
 548:	49 f1       	breq	.+82     	; 0x59c <__LOCK_REGION_LENGTH__+0x19c>
			A2D_convert();
 54a:	80 e0       	ldi	r24, 0x00	; 0
 54c:	ea de       	rcall	.-556    	; 0x322 <Set_A2D_Pin>
			ud_input = ADC;
 54e:	fa de       	rcall	.-524    	; 0x344 <A2D_convert>
 550:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 554:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 558:	90 93 31 02 	sts	0x0231, r25	; 0x800231 <ud_input+0x1>
			if(ud_input > 700) {
 55c:	80 93 30 02 	sts	0x0230, r24	; 0x800230 <ud_input>
 560:	8d 3b       	cpi	r24, 0xBD	; 189
 562:	22 e0       	ldi	r18, 0x02	; 2
				LCD_DisplayString(1, "up");
 564:	92 07       	cpc	r25, r18
 566:	50 f0       	brcs	.+20     	; 0x57c <__LOCK_REGION_LENGTH__+0x17c>
 568:	64 e6       	ldi	r22, 0x64	; 100
 56a:	71 e0       	ldi	r23, 0x01	; 1
				++up_count;
 56c:	81 e0       	ldi	r24, 0x01	; 1
 56e:	49 de       	rcall	.-878    	; 0x202 <LCD_DisplayString>
 570:	80 91 2d 02 	lds	r24, 0x022D	; 0x80022d <up_count>
 574:	8f 5f       	subi	r24, 0xFF	; 255
			}
			else if (ud_input < 350) {
 576:	80 93 2d 02 	sts	0x022D, r24	; 0x80022d <up_count>
				LCD_DisplayString(1, "down");
 57a:	0c c0       	rjmp	.+24     	; 0x594 <__LOCK_REGION_LENGTH__+0x194>
 57c:	8e 35       	cpi	r24, 0x5E	; 94
 57e:	91 40       	sbci	r25, 0x01	; 1
 580:	48 f4       	brcc	.+18     	; 0x594 <__LOCK_REGION_LENGTH__+0x194>
 582:	67 e6       	ldi	r22, 0x67	; 103
				++down_count;
 584:	71 e0       	ldi	r23, 0x01	; 1
 586:	81 e0       	ldi	r24, 0x01	; 1
 588:	3c de       	rcall	.-904    	; 0x202 <LCD_DisplayString>
 58a:	80 91 2c 02 	lds	r24, 0x022C	; 0x80022c <down_count>
			}
			acc_state=jsLR;
 58e:	8f 5f       	subi	r24, 0xFF	; 255
 590:	80 93 2c 02 	sts	0x022C, r24	; 0x80022c <down_count>
			break;
		}
		else if (z == '#') {
			acc_state = jsWait;
 594:	87 e0       	ldi	r24, 0x07	; 7
 596:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
			break;
 59a:	08 95       	ret
		}
		
		case jsLR:
		z = GetKeypadKey();
 59c:	88 e0       	ldi	r24, 0x08	; 8
 59e:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
 5a2:	08 95       	ret
		if (z != '#') {
 5a4:	a1 dd       	rcall	.-1214   	; 0xe8 <GetKeypadKey>
 5a6:	80 93 3d 02 	sts	0x023D, r24	; 0x80023d <z>
			Set_A2D_Pin(0x01);
 5aa:	83 32       	cpi	r24, 0x23	; 35
			A2D_convert();
 5ac:	49 f1       	breq	.+82     	; 0x600 <__LOCK_REGION_LENGTH__+0x200>
 5ae:	81 e0       	ldi	r24, 0x01	; 1
			lr_input = ADC;
 5b0:	b8 de       	rcall	.-656    	; 0x322 <Set_A2D_Pin>
 5b2:	c8 de       	rcall	.-624    	; 0x344 <A2D_convert>
 5b4:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 5b8:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 5bc:	90 93 2f 02 	sts	0x022F, r25	; 0x80022f <lr_input+0x1>
			if(lr_input > 700) {
 5c0:	80 93 2e 02 	sts	0x022E, r24	; 0x80022e <lr_input>
 5c4:	8d 3b       	cpi	r24, 0xBD	; 189
 5c6:	22 e0       	ldi	r18, 0x02	; 2
				LCD_DisplayString(1, "left");
 5c8:	92 07       	cpc	r25, r18
 5ca:	50 f0       	brcs	.+20     	; 0x5e0 <__LOCK_REGION_LENGTH__+0x1e0>
 5cc:	6c e6       	ldi	r22, 0x6C	; 108
 5ce:	71 e0       	ldi	r23, 0x01	; 1
 5d0:	81 e0       	ldi	r24, 0x01	; 1
				++left_count;
 5d2:	17 de       	rcall	.-978    	; 0x202 <LCD_DisplayString>
 5d4:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <left_count>
 5d8:	8f 5f       	subi	r24, 0xFF	; 255
 5da:	80 93 2b 02 	sts	0x022B, r24	; 0x80022b <left_count>
			}
			else if (lr_input < 350) {
 5de:	0c c0       	rjmp	.+24     	; 0x5f8 <__LOCK_REGION_LENGTH__+0x1f8>
 5e0:	8e 35       	cpi	r24, 0x5E	; 94
 5e2:	91 40       	sbci	r25, 0x01	; 1
				LCD_DisplayString(1, "right");
 5e4:	48 f4       	brcc	.+18     	; 0x5f8 <__LOCK_REGION_LENGTH__+0x1f8>
 5e6:	61 e7       	ldi	r22, 0x71	; 113
 5e8:	71 e0       	ldi	r23, 0x01	; 1
 5ea:	81 e0       	ldi	r24, 0x01	; 1
 5ec:	0a de       	rcall	.-1004   	; 0x202 <LCD_DisplayString>
				++right_count;
 5ee:	80 91 2a 02 	lds	r24, 0x022A	; 0x80022a <right_count>
 5f2:	8f 5f       	subi	r24, 0xFF	; 255
 5f4:	80 93 2a 02 	sts	0x022A, r24	; 0x80022a <right_count>
			}
			acc_state=jsUD;
 5f8:	86 e0       	ldi	r24, 0x06	; 6
 5fa:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
			break;
		}
		else if (z == '#') {
			acc_state = jsWait;
 5fe:	08 95       	ret
 600:	88 e0       	ldi	r24, 0x08	; 8
			break;
 602:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
		}
			
			
		case jsWait:
		if ((up_count == up_actual) && (down_count == down_actual) && (left_count == left_actual) && (right_count == right_actual)) {
 606:	08 95       	ret
 608:	90 91 2d 02 	lds	r25, 0x022D	; 0x80022d <up_count>
 60c:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <up_actual>
 610:	98 13       	cpse	r25, r24
 612:	1e c0       	rjmp	.+60     	; 0x650 <__LOCK_REGION_LENGTH__+0x250>
 614:	90 91 2c 02 	lds	r25, 0x022C	; 0x80022c <down_count>
 618:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <down_actual>
 61c:	98 13       	cpse	r25, r24
 61e:	18 c0       	rjmp	.+48     	; 0x650 <__LOCK_REGION_LENGTH__+0x250>
 620:	90 91 2b 02 	lds	r25, 0x022B	; 0x80022b <left_count>
 624:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <left_actual>
 628:	98 13       	cpse	r25, r24
 62a:	12 c0       	rjmp	.+36     	; 0x650 <__LOCK_REGION_LENGTH__+0x250>
 62c:	90 91 2a 02 	lds	r25, 0x022A	; 0x80022a <right_count>
			LCD_DisplayString(1, "Human Verified!");
 630:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <right_actual>
 634:	98 13       	cpse	r25, r24
 636:	0c c0       	rjmp	.+24     	; 0x650 <__LOCK_REGION_LENGTH__+0x250>
 638:	67 e7       	ldi	r22, 0x77	; 119
			eeprom_write_byte(&eeprom_bot, 0);
 63a:	71 e0       	ldi	r23, 0x01	; 1
 63c:	81 e0       	ldi	r24, 0x01	; 1
 63e:	e1 dd       	rcall	.-1086   	; 0x202 <LCD_DisplayString>
 640:	60 e0       	ldi	r22, 0x00	; 0
 642:	8e e0       	ldi	r24, 0x0E	; 14
			acc_state = finish;
 644:	90 e0       	ldi	r25, 0x00	; 0
 646:	48 d2       	rcall	.+1168   	; 0xad8 <eeprom_write_byte>
 648:	89 e0       	ldi	r24, 0x09	; 9
			break;
 64a:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
		}
		else {
			LCD_DisplayString(1, "Human Verified!");
 64e:	08 95       	ret
 650:	67 e7       	ldi	r22, 0x77	; 119
 652:	71 e0       	ldi	r23, 0x01	; 1
 654:	81 e0       	ldi	r24, 0x01	; 1
			eeprom_write_byte(&eeprom_bot, 0);
 656:	d5 dd       	rcall	.-1110   	; 0x202 <LCD_DisplayString>
 658:	60 e0       	ldi	r22, 0x00	; 0
 65a:	8e e0       	ldi	r24, 0x0E	; 14
 65c:	90 e0       	ldi	r25, 0x00	; 0
 65e:	3c d2       	rcall	.+1144   	; 0xad8 <eeprom_write_byte>
			// LCD_ClearScreen();
			acc_state = finish;
 660:	89 e0       	ldi	r24, 0x09	; 9
 662:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
 666:	08 95       	ret

00000668 <login>:
		// LCD_ClearScreen();
		break;
	}
}

void login() {
 668:	cf 93       	push	r28
	switch(login_state) {
 66a:	e0 91 42 02 	lds	r30, 0x0242	; 0x800242 <login_state>
 66e:	8e 2f       	mov	r24, r30
 670:	90 e0       	ldi	r25, 0x00	; 0
 672:	87 30       	cpi	r24, 0x07	; 7
 674:	91 05       	cpc	r25, r1
 676:	08 f0       	brcs	.+2      	; 0x67a <login+0x12>
 678:	7b c1       	rjmp	.+758    	; 0x970 <login+0x308>
 67a:	fc 01       	movw	r30, r24
 67c:	e1 5b       	subi	r30, 0xB1	; 177
 67e:	ff 4f       	sbci	r31, 0xFF	; 255
 680:	08 c2       	rjmp	.+1040   	; 0xa92 <__tablejump2__>
 682:	2f eb       	ldi	r18, 0xBF	; 191
 684:	86 ec       	ldi	r24, 0xC6	; 198
 686:	9d e2       	ldi	r25, 0x2D	; 45
 688:	21 50       	subi	r18, 0x01	; 1
 68a:	80 40       	sbci	r24, 0x00	; 0
 68c:	90 40       	sbci	r25, 0x00	; 0
 68e:	e1 f7       	brne	.-8      	; 0x688 <login+0x20>
 690:	00 c0       	rjmp	.+0      	; 0x692 <login+0x2a>
 692:	00 00       	nop
		case init:
		_delay_ms(15000);
		LCD_DisplayString(1, "Enter Password");
 694:	67 e8       	ldi	r22, 0x87	; 135
 696:	71 e0       	ldi	r23, 0x01	; 1
 698:	81 e0       	ldi	r24, 0x01	; 1
 69a:	b3 dd       	rcall	.-1178   	; 0x202 <LCD_DisplayString>
		login_state = enterPass;
 69c:	81 e0       	ldi	r24, 0x01	; 1
 69e:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
		break;
 6a2:	66 c1       	rjmp	.+716    	; 0x970 <login+0x308>
		
		case enterPass:
		if (try == 1) {
 6a4:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 6a8:	81 30       	cpi	r24, 0x01	; 1
			a = GetKeypadKey();
 6aa:	11 f5       	brne	.+68     	; 0x6f0 <login+0x88>
 6ac:	1d dd       	rcall	.-1478   	; 0xe8 <GetKeypadKey>
 6ae:	80 93 43 02 	sts	0x0243, r24	; 0x800243 <a>
			if (n >= 4) {
 6b2:	90 91 25 02 	lds	r25, 0x0225	; 0x800225 <n>
 6b6:	94 30       	cpi	r25, 0x04	; 4
 6b8:	20 f0       	brcs	.+8      	; 0x6c2 <login+0x5a>
				login_state = checkPass;
 6ba:	82 e0       	ldi	r24, 0x02	; 2
 6bc:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
				break;
 6c0:	57 c1       	rjmp	.+686    	; 0x970 <login+0x308>
			}
			else if (a != '\0') {
 6c2:	88 23       	and	r24, r24
				LCD_Cursor(17+n);
 6c4:	89 f0       	breq	.+34     	; 0x6e8 <login+0x80>
 6c6:	81 e1       	ldi	r24, 0x11	; 17
 6c8:	89 0f       	add	r24, r25
				LCD_WriteData('*');
 6ca:	7b dd       	rcall	.-1290   	; 0x1c2 <LCD_Cursor>
 6cc:	8a e2       	ldi	r24, 0x2A	; 42
 6ce:	90 dd       	rcall	.-1248   	; 0x1f0 <LCD_WriteData>
				ram_pass[n] = a;
 6d0:	80 91 25 02 	lds	r24, 0x0225	; 0x800225 <n>
 6d4:	e8 2f       	mov	r30, r24
 6d6:	f0 e0       	ldi	r31, 0x00	; 0
 6d8:	e9 5e       	subi	r30, 0xE9	; 233
 6da:	fd 4f       	sbci	r31, 0xFD	; 253
 6dc:	90 91 43 02 	lds	r25, 0x0243	; 0x800243 <a>
 6e0:	90 83       	st	Z, r25
				n++;
 6e2:	8f 5f       	subi	r24, 0xFF	; 255
 6e4:	80 93 25 02 	sts	0x0225, r24	; 0x800225 <n>
			}
			login_state = enterPass;
 6e8:	81 e0       	ldi	r24, 0x01	; 1
 6ea:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
			break;
		}
		else if (try == 2) {
 6ee:	40 c1       	rjmp	.+640    	; 0x970 <login+0x308>
 6f0:	82 30       	cpi	r24, 0x02	; 2
			b = GetKeypadKey();
 6f2:	11 f5       	brne	.+68     	; 0x738 <login+0xd0>
 6f4:	f9 dc       	rcall	.-1550   	; 0xe8 <GetKeypadKey>
 6f6:	80 93 38 02 	sts	0x0238, r24	; 0x800238 <b>
			if (o >= 4) {
 6fa:	90 91 24 02 	lds	r25, 0x0224	; 0x800224 <o>
 6fe:	94 30       	cpi	r25, 0x04	; 4
 700:	20 f0       	brcs	.+8      	; 0x70a <login+0xa2>
				login_state = checkPass;
 702:	82 e0       	ldi	r24, 0x02	; 2
 704:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
				break;
			}
			else if (b != '\0') {
 708:	33 c1       	rjmp	.+614    	; 0x970 <login+0x308>
				LCD_Cursor(17+o);
 70a:	88 23       	and	r24, r24
 70c:	89 f0       	breq	.+34     	; 0x730 <login+0xc8>
 70e:	81 e1       	ldi	r24, 0x11	; 17
 710:	89 0f       	add	r24, r25
				LCD_WriteData('*');
 712:	57 dd       	rcall	.-1362   	; 0x1c2 <LCD_Cursor>
 714:	8a e2       	ldi	r24, 0x2A	; 42
 716:	6c dd       	rcall	.-1320   	; 0x1f0 <LCD_WriteData>
				ram_pass[o] = b;
 718:	80 91 24 02 	lds	r24, 0x0224	; 0x800224 <o>
 71c:	e8 2f       	mov	r30, r24
 71e:	f0 e0       	ldi	r31, 0x00	; 0
 720:	e9 5e       	subi	r30, 0xE9	; 233
 722:	fd 4f       	sbci	r31, 0xFD	; 253
 724:	90 91 38 02 	lds	r25, 0x0238	; 0x800238 <b>
 728:	90 83       	st	Z, r25
				o++;
 72a:	8f 5f       	subi	r24, 0xFF	; 255
 72c:	80 93 24 02 	sts	0x0224, r24	; 0x800224 <o>
			}
			login_state = enterPass;
 730:	81 e0       	ldi	r24, 0x01	; 1
 732:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
			break;
		}
		else if (try == 3) {
 736:	1c c1       	rjmp	.+568    	; 0x970 <login+0x308>
 738:	83 30       	cpi	r24, 0x03	; 3
 73a:	09 f0       	breq	.+2      	; 0x73e <login+0xd6>
			c = GetKeypadKey();
 73c:	19 c1       	rjmp	.+562    	; 0x970 <login+0x308>
 73e:	d4 dc       	rcall	.-1624   	; 0xe8 <GetKeypadKey>
 740:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <c>
			if (p >= 4) {
 744:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <p>
 748:	94 30       	cpi	r25, 0x04	; 4
				login_state = checkPass;
 74a:	20 f0       	brcs	.+8      	; 0x754 <login+0xec>
 74c:	82 e0       	ldi	r24, 0x02	; 2
				break;
 74e:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
			}
			else if (c != '\0') {
 752:	0e c1       	rjmp	.+540    	; 0x970 <login+0x308>
				LCD_Cursor(17+p);
 754:	88 23       	and	r24, r24
 756:	89 f0       	breq	.+34     	; 0x77a <login+0x112>
 758:	81 e1       	ldi	r24, 0x11	; 17
 75a:	89 0f       	add	r24, r25
				LCD_WriteData('*');
 75c:	32 dd       	rcall	.-1436   	; 0x1c2 <LCD_Cursor>
 75e:	8a e2       	ldi	r24, 0x2A	; 42
 760:	47 dd       	rcall	.-1394   	; 0x1f0 <LCD_WriteData>
				ram_pass[p] = c;
 762:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <p>
 766:	e8 2f       	mov	r30, r24
 768:	f0 e0       	ldi	r31, 0x00	; 0
 76a:	e9 5e       	subi	r30, 0xE9	; 233
 76c:	fd 4f       	sbci	r31, 0xFD	; 253
 76e:	90 91 3f 02 	lds	r25, 0x023F	; 0x80023f <c>
 772:	90 83       	st	Z, r25
				p++;
 774:	8f 5f       	subi	r24, 0xFF	; 255
 776:	80 93 23 02 	sts	0x0223, r24	; 0x800223 <p>
			}
			login_state = enterPass;
 77a:	81 e0       	ldi	r24, 0x01	; 1
 77c:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
			break;
		}
		break;
		
		case checkPass:
		if ( (ram_pass[0] == eeprom_read_byte(&eeprom_pass[0])) && (ram_pass[1] == eeprom_read_byte(&eeprom_pass[1])) && (ram_pass[2] == eeprom_read_byte(&eeprom_pass[2])) && (ram_pass[3] == eeprom_read_byte(&eeprom_pass[3])) ) {
 780:	f7 c0       	rjmp	.+494    	; 0x970 <login+0x308>
 782:	c0 91 17 02 	lds	r28, 0x0217	; 0x800217 <ram_pass>
 786:	84 e0       	ldi	r24, 0x04	; 4
 788:	90 e0       	ldi	r25, 0x00	; 0
 78a:	8c d1       	rcall	.+792    	; 0xaa4 <eeprom_read_byte>
 78c:	c8 13       	cpse	r28, r24
 78e:	2a c0       	rjmp	.+84     	; 0x7e4 <login+0x17c>
 790:	c0 91 18 02 	lds	r28, 0x0218	; 0x800218 <ram_pass+0x1>
 794:	85 e0       	ldi	r24, 0x05	; 5
 796:	90 e0       	ldi	r25, 0x00	; 0
 798:	85 d1       	rcall	.+778    	; 0xaa4 <eeprom_read_byte>
 79a:	c8 13       	cpse	r28, r24
 79c:	23 c0       	rjmp	.+70     	; 0x7e4 <login+0x17c>
 79e:	c0 91 19 02 	lds	r28, 0x0219	; 0x800219 <ram_pass+0x2>
 7a2:	86 e0       	ldi	r24, 0x06	; 6
 7a4:	90 e0       	ldi	r25, 0x00	; 0
 7a6:	7e d1       	rcall	.+764    	; 0xaa4 <eeprom_read_byte>
 7a8:	c8 13       	cpse	r28, r24
 7aa:	1c c0       	rjmp	.+56     	; 0x7e4 <login+0x17c>
 7ac:	c0 91 1a 02 	lds	r28, 0x021A	; 0x80021a <ram_pass+0x3>
 7b0:	87 e0       	ldi	r24, 0x07	; 7
 7b2:	90 e0       	ldi	r25, 0x00	; 0
 7b4:	77 d1       	rcall	.+750    	; 0xaa4 <eeprom_read_byte>
 7b6:	c8 13       	cpse	r28, r24
			LCD_DisplayString(1, "Password CorrectLogin Successful");
 7b8:	15 c0       	rjmp	.+42     	; 0x7e4 <login+0x17c>
 7ba:	66 e9       	ldi	r22, 0x96	; 150
 7bc:	71 e0       	ldi	r23, 0x01	; 1
 7be:	81 e0       	ldi	r24, 0x01	; 1
			transferdata(0xF8);
 7c0:	20 dd       	rcall	.-1472   	; 0x202 <LCD_DisplayString>
 7c2:	88 ef       	ldi	r24, 0xF8	; 248
 7c4:	c8 dd       	rcall	.-1136   	; 0x356 <transferdata>
 7c6:	2f eb       	ldi	r18, 0xBF	; 191
 7c8:	86 ec       	ldi	r24, 0xC6	; 198
 7ca:	9d e2       	ldi	r25, 0x2D	; 45
 7cc:	21 50       	subi	r18, 0x01	; 1
 7ce:	80 40       	sbci	r24, 0x00	; 0
 7d0:	90 40       	sbci	r25, 0x00	; 0
 7d2:	e1 f7       	brne	.-8      	; 0x7cc <login+0x164>
 7d4:	00 c0       	rjmp	.+0      	; 0x7d6 <login+0x16e>
			_delay_ms(15000);
			transferdata(0x00);
 7d6:	00 00       	nop
 7d8:	80 e0       	ldi	r24, 0x00	; 0
 7da:	bd dd       	rcall	.-1158   	; 0x356 <transferdata>
			login_state = done;
 7dc:	87 e0       	ldi	r24, 0x07	; 7
 7de:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
			break;
 7e2:	c6 c0       	rjmp	.+396    	; 0x970 <login+0x308>
		}
		else {
			try++;
 7e4:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 7e8:	8f 5f       	subi	r24, 0xFF	; 255
 7ea:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
			if (try < 4) {
 7ee:	84 30       	cpi	r24, 0x04	; 4
				LCD_DisplayString(1, "Password wrong!");
 7f0:	38 f4       	brcc	.+14     	; 0x800 <login+0x198>
 7f2:	67 eb       	ldi	r22, 0xB7	; 183
 7f4:	71 e0       	ldi	r23, 0x01	; 1
 7f6:	81 e0       	ldi	r24, 0x01	; 1
				login_state = init;
 7f8:	04 dd       	rcall	.-1528   	; 0x202 <LCD_DisplayString>
 7fa:	10 92 42 02 	sts	0x0242, r1	; 0x800242 <login_state>
				break;
			}
			if (try == 4) {
 7fe:	b8 c0       	rjmp	.+368    	; 0x970 <login+0x308>
 800:	84 30       	cpi	r24, 0x04	; 4
 802:	09 f0       	breq	.+2      	; 0x806 <login+0x19e>
				LCD_DisplayString(1, "Enter Pin");
 804:	b5 c0       	rjmp	.+362    	; 0x970 <login+0x308>
 806:	67 ec       	ldi	r22, 0xC7	; 199
 808:	71 e0       	ldi	r23, 0x01	; 1
 80a:	81 e0       	ldi	r24, 0x01	; 1
				login_state = enterPin;
 80c:	fa dc       	rcall	.-1548   	; 0x202 <LCD_DisplayString>
 80e:	83 e0       	ldi	r24, 0x03	; 3
				break;
 810:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
			}
		}
		break;
		
		case enterPin:
		d = GetKeypadKey();
 814:	ad c0       	rjmp	.+346    	; 0x970 <login+0x308>
 816:	68 dc       	rcall	.-1840   	; 0xe8 <GetKeypadKey>
 818:	80 93 41 02 	sts	0x0241, r24	; 0x800241 <d>
		if (q >= 3) {
 81c:	90 91 22 02 	lds	r25, 0x0222	; 0x800222 <q>
 820:	93 30       	cpi	r25, 0x03	; 3
			login_state = checkPin;
 822:	20 f0       	brcs	.+8      	; 0x82c <login+0x1c4>
 824:	84 e0       	ldi	r24, 0x04	; 4
 826:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
			break;
		}
		else if (d != '\0') {
 82a:	a2 c0       	rjmp	.+324    	; 0x970 <login+0x308>
 82c:	88 23       	and	r24, r24
			LCD_Cursor(17+q);
 82e:	89 f0       	breq	.+34     	; 0x852 <login+0x1ea>
 830:	81 e1       	ldi	r24, 0x11	; 17
 832:	89 0f       	add	r24, r25
 834:	c6 dc       	rcall	.-1652   	; 0x1c2 <LCD_Cursor>
			LCD_WriteData('*');
 836:	8a e2       	ldi	r24, 0x2A	; 42
 838:	db dc       	rcall	.-1610   	; 0x1f0 <LCD_WriteData>
			ram_pin[q] = d;
 83a:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <q>
 83e:	e8 2f       	mov	r30, r24
 840:	f0 e0       	ldi	r31, 0x00	; 0
 842:	ed 5e       	subi	r30, 0xED	; 237
 844:	fd 4f       	sbci	r31, 0xFD	; 253
 846:	90 91 41 02 	lds	r25, 0x0241	; 0x800241 <d>
			q++;
 84a:	90 83       	st	Z, r25
 84c:	8f 5f       	subi	r24, 0xFF	; 255
		}
		login_state = enterPin;
 84e:	80 93 22 02 	sts	0x0222, r24	; 0x800222 <q>
 852:	83 e0       	ldi	r24, 0x03	; 3
		break;
 854:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
		
		case checkPin:
		if ( (ram_pin[0] == eeprom_read_byte(&eeprom_pin[0])) && (ram_pin[1] == eeprom_read_byte(&eeprom_pin[1])) && (ram_pin[2] == eeprom_read_byte(&eeprom_pin[2])) ) {
 858:	8b c0       	rjmp	.+278    	; 0x970 <login+0x308>
 85a:	c0 91 13 02 	lds	r28, 0x0213	; 0x800213 <ram_pin>
 85e:	80 e0       	ldi	r24, 0x00	; 0
 860:	90 e0       	ldi	r25, 0x00	; 0
 862:	20 d1       	rcall	.+576    	; 0xaa4 <eeprom_read_byte>
 864:	c8 13       	cpse	r28, r24
 866:	16 c0       	rjmp	.+44     	; 0x894 <login+0x22c>
 868:	c0 91 14 02 	lds	r28, 0x0214	; 0x800214 <ram_pin+0x1>
 86c:	81 e0       	ldi	r24, 0x01	; 1
 86e:	90 e0       	ldi	r25, 0x00	; 0
 870:	19 d1       	rcall	.+562    	; 0xaa4 <eeprom_read_byte>
 872:	c8 13       	cpse	r28, r24
 874:	0f c0       	rjmp	.+30     	; 0x894 <login+0x22c>
 876:	c0 91 15 02 	lds	r28, 0x0215	; 0x800215 <ram_pin+0x2>
 87a:	82 e0       	ldi	r24, 0x02	; 2
 87c:	90 e0       	ldi	r25, 0x00	; 0
 87e:	12 d1       	rcall	.+548    	; 0xaa4 <eeprom_read_byte>
			LCD_DisplayString(1, "Reset Password");
 880:	c8 13       	cpse	r28, r24
 882:	08 c0       	rjmp	.+16     	; 0x894 <login+0x22c>
 884:	61 ed       	ldi	r22, 0xD1	; 209
 886:	71 e0       	ldi	r23, 0x01	; 1
			login_state = resetPw;
 888:	81 e0       	ldi	r24, 0x01	; 1
 88a:	bb dc       	rcall	.-1674   	; 0x202 <LCD_DisplayString>
 88c:	85 e0       	ldi	r24, 0x05	; 5
			break;
 88e:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
		}
		else {
			LCD_DisplayString(1, "Wrong Bye!");
 892:	6e c0       	rjmp	.+220    	; 0x970 <login+0x308>
 894:	60 ee       	ldi	r22, 0xE0	; 224
 896:	71 e0       	ldi	r23, 0x01	; 1
 898:	81 e0       	ldi	r24, 0x01	; 1
 89a:	b3 dc       	rcall	.-1690   	; 0x202 <LCD_DisplayString>
 89c:	2f eb       	ldi	r18, 0xBF	; 191
 89e:	86 ec       	ldi	r24, 0xC6	; 198
 8a0:	9d e2       	ldi	r25, 0x2D	; 45
 8a2:	21 50       	subi	r18, 0x01	; 1
 8a4:	80 40       	sbci	r24, 0x00	; 0
 8a6:	90 40       	sbci	r25, 0x00	; 0
			_delay_ms(15000);
			LCD_ClearScreen();
 8a8:	e1 f7       	brne	.-8      	; 0x8a2 <login+0x23a>
			login_state = finish;
 8aa:	00 c0       	rjmp	.+0      	; 0x8ac <login+0x244>
 8ac:	00 00       	nop
 8ae:	86 dc       	rcall	.-1780   	; 0x1bc <LCD_ClearScreen>
			break;
 8b0:	89 e0       	ldi	r24, 0x09	; 9
		}
		break;
		
		case resetPw:
		e = GetKeypadKey();
 8b2:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
 8b6:	5c c0       	rjmp	.+184    	; 0x970 <login+0x308>
 8b8:	17 dc       	rcall	.-2002   	; 0xe8 <GetKeypadKey>
		if (r >= 4) {
 8ba:	80 93 44 02 	sts	0x0244, r24	; 0x800244 <e>
 8be:	90 91 21 02 	lds	r25, 0x0221	; 0x800221 <r>
			LCD_DisplayString(1, "Password Reset");
 8c2:	94 30       	cpi	r25, 0x04	; 4
 8c4:	a8 f0       	brcs	.+42     	; 0x8f0 <login+0x288>
 8c6:	6b ee       	ldi	r22, 0xEB	; 235
 8c8:	71 e0       	ldi	r23, 0x01	; 1
			transferdata(0xF8);
 8ca:	81 e0       	ldi	r24, 0x01	; 1
 8cc:	9a dc       	rcall	.-1740   	; 0x202 <LCD_DisplayString>
 8ce:	88 ef       	ldi	r24, 0xF8	; 248
 8d0:	42 dd       	rcall	.-1404   	; 0x356 <transferdata>
 8d2:	2f eb       	ldi	r18, 0xBF	; 191
 8d4:	86 ec       	ldi	r24, 0xC6	; 198
 8d6:	9d e2       	ldi	r25, 0x2D	; 45
 8d8:	21 50       	subi	r18, 0x01	; 1
 8da:	80 40       	sbci	r24, 0x00	; 0
 8dc:	90 40       	sbci	r25, 0x00	; 0
 8de:	e1 f7       	brne	.-8      	; 0x8d8 <login+0x270>
			_delay_ms(15000);
			transferdata(0x00);
 8e0:	00 c0       	rjmp	.+0      	; 0x8e2 <login+0x27a>
 8e2:	00 00       	nop
 8e4:	80 e0       	ldi	r24, 0x00	; 0
			acc_state = done;
 8e6:	37 dd       	rcall	.-1426   	; 0x356 <transferdata>
 8e8:	87 e0       	ldi	r24, 0x07	; 7
 8ea:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
			break;
		}
		else if (e != '\0') {
 8ee:	40 c0       	rjmp	.+128    	; 0x970 <login+0x308>
 8f0:	88 23       	and	r24, r24
 8f2:	09 f4       	brne	.+2      	; 0x8f6 <login+0x28e>
			LCD_Cursor(17+r);
 8f4:	3d c0       	rjmp	.+122    	; 0x970 <login+0x308>
 8f6:	81 e1       	ldi	r24, 0x11	; 17
 8f8:	89 0f       	add	r24, r25
 8fa:	63 dc       	rcall	.-1850   	; 0x1c2 <LCD_Cursor>
			LCD_WriteData(e);
 8fc:	80 91 44 02 	lds	r24, 0x0244	; 0x800244 <e>
 900:	77 dc       	rcall	.-1810   	; 0x1f0 <LCD_WriteData>
 902:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <r>
			eeprom_update_byte(&eeprom_pass[r], e);
 906:	90 e0       	ldi	r25, 0x00	; 0
 908:	60 91 44 02 	lds	r22, 0x0244	; 0x800244 <e>
 90c:	8c 5f       	subi	r24, 0xFC	; 252
 90e:	9f 4f       	sbci	r25, 0xFF	; 255
 910:	d1 d0       	rcall	.+418    	; 0xab4 <eeprom_update_byte>
 912:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <r>
			r++;
 916:	8f 5f       	subi	r24, 0xFF	; 255
 918:	80 93 21 02 	sts	0x0221, r24	; 0x800221 <r>
 91c:	85 e0       	ldi	r24, 0x05	; 5
			acc_state = resetPw;
 91e:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <acc_state>
 922:	26 c0       	rjmp	.+76     	; 0x970 <login+0x308>
		}
		break;
		
		
		case wrongWait:
		if (try < 3) {
 924:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 928:	83 30       	cpi	r24, 0x03	; 3
 92a:	30 f4       	brcc	.+12     	; 0x938 <login+0x2d0>
			try++;
 92c:	8f 5f       	subi	r24, 0xFF	; 255
 92e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
			login_state = init;
 932:	10 92 42 02 	sts	0x0242, r1	; 0x800242 <login_state>
			break;
 936:	1c c0       	rjmp	.+56     	; 0x970 <login+0x308>
 938:	2f eb       	ldi	r18, 0xBF	; 191
 93a:	86 ec       	ldi	r24, 0xC6	; 198
 93c:	9d e2       	ldi	r25, 0x2D	; 45
 93e:	21 50       	subi	r18, 0x01	; 1
 940:	80 40       	sbci	r24, 0x00	; 0
 942:	90 40       	sbci	r25, 0x00	; 0
 944:	e1 f7       	brne	.-8      	; 0x93e <login+0x2d6>
 946:	00 c0       	rjmp	.+0      	; 0x948 <login+0x2e0>
 948:	00 00       	nop
		}
		else {
			_delay_ms(15000);
			LCD_DisplayString(1, "Bye!");
 94a:	66 ee       	ldi	r22, 0xE6	; 230
 94c:	71 e0       	ldi	r23, 0x01	; 1
 94e:	81 e0       	ldi	r24, 0x01	; 1
 950:	58 dc       	rcall	.-1872   	; 0x202 <LCD_DisplayString>
 952:	2f eb       	ldi	r18, 0xBF	; 191
 954:	86 ec       	ldi	r24, 0xC6	; 198
 956:	9d e2       	ldi	r25, 0x2D	; 45
 958:	21 50       	subi	r18, 0x01	; 1
 95a:	80 40       	sbci	r24, 0x00	; 0
 95c:	90 40       	sbci	r25, 0x00	; 0
 95e:	e1 f7       	brne	.-8      	; 0x958 <login+0x2f0>
 960:	00 c0       	rjmp	.+0      	; 0x962 <login+0x2fa>
 962:	00 00       	nop
 964:	2b dc       	rcall	.-1962   	; 0x1bc <LCD_ClearScreen>
			_delay_ms(15000);
			LCD_ClearScreen();
 966:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__data_start>
			try = 0;
 96a:	87 e0       	ldi	r24, 0x07	; 7
 96c:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <login_state>
			login_state = done;
 970:	cf 91       	pop	r28
 972:	08 95       	ret

00000974 <main>:
		
		case done:
		break;
		
	}
}
 974:	cf 93       	push	r28
 976:	df 93       	push	r29
	ADCSRA |=(1<<ADSC); // begin converting
	while ( !(ADCSRA & (1<<ADIF))); // wait to make sure all pins are read
}

int main(void)
{
 978:	cd b7       	in	r28, 0x3d	; 61
 97a:	de b7       	in	r29, 0x3e	; 62
 97c:	28 97       	sbiw	r28, 0x08	; 8
 97e:	0f b6       	in	r0, 0x3f	; 63
 980:	f8 94       	cli
 982:	de bf       	out	0x3e, r29	; 62
 984:	0f be       	out	0x3f, r0	; 63
 986:	cd bf       	out	0x3d, r28	; 61
	/* Replace with your application code */
	DDRC = 0xF0; PORTC = 0x0F; // keypad
 988:	80 ef       	ldi	r24, 0xF0	; 240
 98a:	87 b9       	out	0x07, r24	; 7
 98c:	8f e0       	ldi	r24, 0x0F	; 15
 98e:	88 b9       	out	0x08, r24	; 8
	DDRB = 0xFF; PORTB = 0x00; // LCD & shift register
 990:	8f ef       	ldi	r24, 0xFF	; 255
 992:	84 b9       	out	0x04, r24	; 4
 994:	15 b8       	out	0x05, r1	; 5
	DDRD = 0xFF; PORTD = 0x00; // LCD
 996:	8a b9       	out	0x0a, r24	; 10
 998:	1b b8       	out	0x0b, r1	; 11
	DDRA = 0x00; PORTA = 0xFF; // joystick
 99a:	11 b8       	out	0x01, r1	; 1
 99c:	82 b9       	out	0x02, r24	; 2
	
	
	unsigned char humPattern[] = {0x0e, 0x0e, 0x04, 0x04, 0x1f, 0x04, 0x0a, 0x0a} ;
 99e:	88 e0       	ldi	r24, 0x08	; 8
 9a0:	e9 e0       	ldi	r30, 0x09	; 9
 9a2:	f1 e0       	ldi	r31, 0x01	; 1
 9a4:	de 01       	movw	r26, r28
 9a6:	11 96       	adiw	r26, 0x01	; 1
 9a8:	01 90       	ld	r0, Z+
 9aa:	0d 92       	st	X+, r0
 9ac:	8a 95       	dec	r24
 9ae:	e1 f7       	brne	.-8      	; 0x9a8 <main+0x34>
	
	TimerOn();
 9b0:	52 dc       	rcall	.-1884   	; 0x256 <TimerOn>
	TimerSet(300);
 9b2:	6c e2       	ldi	r22, 0x2C	; 44
 9b4:	71 e0       	ldi	r23, 0x01	; 1
 9b6:	80 e0       	ldi	r24, 0x00	; 0
 9b8:	90 e0       	ldi	r25, 0x00	; 0
 9ba:	3c dc       	rcall	.-1928   	; 0x234 <TimerSet>
	
	transferdata(0x00); // clears lights
 9bc:	80 e0       	ldi	r24, 0x00	; 0
 9be:	90 e0       	ldi	r25, 0x00	; 0
	
	A2D_init();
 9c0:	ca dc       	rcall	.-1644   	; 0x356 <transferdata>
	
	LCD_init();
 9c2:	a9 dc       	rcall	.-1710   	; 0x316 <A2D_init>
	LCD_WriteCommand(0x38); //Function Set: 8-bit, 2 Line, 5x7 Dots
 9c4:	06 dc       	rcall	.-2036   	; 0x1d2 <LCD_init>
 9c6:	88 e3       	ldi	r24, 0x38	; 56
	LCD_WriteCommand(0x01); //Clear LCD
 9c8:	f0 db       	rcall	.-2080   	; 0x1aa <LCD_WriteCommand>
 9ca:	81 e0       	ldi	r24, 0x01	; 1
	LCD_WriteCommand(0x06); //Entry Mode
 9cc:	ee db       	rcall	.-2084   	; 0x1aa <LCD_WriteCommand>
 9ce:	86 e0       	ldi	r24, 0x06	; 6
 9d0:	ec db       	rcall	.-2088   	; 0x1aa <LCD_WriteCommand>
	LCD_WriteCommand(0x0c); //Display on Cursor off
 9d2:	8c e0       	ldi	r24, 0x0C	; 12
 9d4:	ea db       	rcall	.-2092   	; 0x1aa <LCD_WriteCommand>
	
	ram_user[4] = eeprom_read_byte(&eeprom_user[4]);
 9d6:	8d e0       	ldi	r24, 0x0D	; 13
 9d8:	90 e0       	ldi	r25, 0x00	; 0
 9da:	64 d0       	rcall	.+200    	; 0xaa4 <eeprom_read_byte>
 9dc:	18 2f       	mov	r17, r24
 9de:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <ram_user+0x4>
 9e2:	8e e0       	ldi	r24, 0x0E	; 14
	ram_bot = eeprom_read_byte(&eeprom_bot);
 9e4:	90 e0       	ldi	r25, 0x00	; 0
 9e6:	5e d0       	rcall	.+188    	; 0xaa4 <eeprom_read_byte>
 9e8:	80 93 32 02 	sts	0x0232, r24	; 0x800232 <ram_bot>
 9ec:	11 30       	cpi	r17, 0x01	; 1
	
	
	if (ram_user[4] == 1 && ram_bot == 0) { // username made
 9ee:	09 f0       	breq	.+2      	; 0x9f2 <main+0x7e>
 9f0:	34 c0       	rjmp	.+104    	; 0xa5a <main+0xe6>
 9f2:	81 11       	cpse	r24, r1
		LCD_DisplayString(1, "Welcome  ");
 9f4:	32 c0       	rjmp	.+100    	; 0xa5a <main+0xe6>
 9f6:	6a ef       	ldi	r22, 0xFA	; 250
 9f8:	71 e0       	ldi	r23, 0x01	; 1
 9fa:	81 e0       	ldi	r24, 0x01	; 1
		
		// creating the character
		customchar(humPattern,1);
 9fc:	02 dc       	rcall	.-2044   	; 0x202 <LCD_DisplayString>
 9fe:	61 e0       	ldi	r22, 0x01	; 1
 a00:	70 e0       	ldi	r23, 0x00	; 0
 a02:	ce 01       	movw	r24, r28
 a04:	01 96       	adiw	r24, 0x01	; 1
 a06:	c5 dc       	rcall	.-1654   	; 0x392 <customchar>
		LCD_WriteCommand(0x88);    //Place cursor at 8th position of first row
 a08:	88 e8       	ldi	r24, 0x88	; 136
 a0a:	cf db       	rcall	.-2146   	; 0x1aa <LCD_WriteCommand>
		LCD_WriteData( 1 );
 a0c:	81 e0       	ldi	r24, 0x01	; 1
 a0e:	f0 db       	rcall	.-2080   	; 0x1f0 <LCD_WriteData>
		
		
		// outputting the username
		ram_user[0] = eeprom_read_byte(&eeprom_user[0]);
 a10:	89 e0       	ldi	r24, 0x09	; 9
 a12:	90 e0       	ldi	r25, 0x00	; 0
 a14:	47 d0       	rcall	.+142    	; 0xaa4 <eeprom_read_byte>
 a16:	0c e1       	ldi	r16, 0x1C	; 28
 a18:	12 e0       	ldi	r17, 0x02	; 2
 a1a:	f8 01       	movw	r30, r16
 a1c:	80 83       	st	Z, r24
		ram_user[1] = eeprom_read_byte(&eeprom_user[1]);
 a1e:	8a e0       	ldi	r24, 0x0A	; 10
 a20:	90 e0       	ldi	r25, 0x00	; 0
 a22:	40 d0       	rcall	.+128    	; 0xaa4 <eeprom_read_byte>
 a24:	f8 01       	movw	r30, r16
		ram_user[2] = eeprom_read_byte(&eeprom_user[2]);
 a26:	81 83       	std	Z+1, r24	; 0x01
 a28:	8b e0       	ldi	r24, 0x0B	; 11
 a2a:	90 e0       	ldi	r25, 0x00	; 0
 a2c:	3b d0       	rcall	.+118    	; 0xaa4 <eeprom_read_byte>
		ram_user[3] = eeprom_read_byte(&eeprom_user[3]);
 a2e:	f8 01       	movw	r30, r16
 a30:	82 83       	std	Z+2, r24	; 0x02
 a32:	8c e0       	ldi	r24, 0x0C	; 12
 a34:	90 e0       	ldi	r25, 0x00	; 0
 a36:	36 d0       	rcall	.+108    	; 0xaa4 <eeprom_read_byte>
		LCD_Cursor(11);
 a38:	f8 01       	movw	r30, r16
 a3a:	83 83       	std	Z+3, r24	; 0x03
 a3c:	8b e0       	ldi	r24, 0x0B	; 11
		LCD_WriteData(ram_user[0]);
 a3e:	c1 db       	rcall	.-2174   	; 0x1c2 <LCD_Cursor>
 a40:	f8 01       	movw	r30, r16
 a42:	80 81       	ld	r24, Z
		LCD_WriteData(ram_user[1]);
 a44:	d5 db       	rcall	.-2134   	; 0x1f0 <LCD_WriteData>
 a46:	f8 01       	movw	r30, r16
 a48:	81 81       	ldd	r24, Z+1	; 0x01
 a4a:	d2 db       	rcall	.-2140   	; 0x1f0 <LCD_WriteData>
		LCD_WriteData(ram_user[2]);
 a4c:	f8 01       	movw	r30, r16
 a4e:	82 81       	ldd	r24, Z+2	; 0x02
 a50:	cf db       	rcall	.-2146   	; 0x1f0 <LCD_WriteData>
 a52:	f8 01       	movw	r30, r16
		LCD_WriteData(ram_user[3]);
 a54:	83 81       	ldd	r24, Z+3	; 0x03
 a56:	cc db       	rcall	.-2152   	; 0x1f0 <LCD_WriteData>
 a58:	04 c0       	rjmp	.+8      	; 0xa62 <main+0xee>
 a5a:	64 e0       	ldi	r22, 0x04	; 4
	
	ram_user[4] = eeprom_read_byte(&eeprom_user[4]);
	ram_bot = eeprom_read_byte(&eeprom_bot);
	
	
	if (ram_user[4] == 1 && ram_bot == 0) { // username made
 a5c:	72 e0       	ldi	r23, 0x02	; 2
		LCD_WriteData(ram_user[1]);
		LCD_WriteData(ram_user[2]);
		LCD_WriteData(ram_user[3]);
	}
	else { // no username made
		LCD_DisplayString(1, "Make Username");
 a5e:	81 e0       	ldi	r24, 0x01	; 1
 a60:	d0 db       	rcall	.-2144   	; 0x202 <LCD_DisplayString>
 a62:	81 e1       	ldi	r24, 0x11	; 17
	}
	
	// state = start;
	cursor = 17;
 a64:	80 93 3e 02 	sts	0x023E, r24	; 0x80023e <cursor>
 a68:	ac db       	rcall	.-2216   	; 0x1c2 <LCD_Cursor>
	LCD_Cursor(cursor);
 a6a:	0c e1       	ldi	r16, 0x1C	; 28
 a6c:	12 e0       	ldi	r17, 0x02	; 2
	
	while (1)
	{
		while(!TimerFlag) {};
		TimerFlag = 0;
		if (ram_user[4] == 1 && ram_bot == 0) {
 a6e:	80 91 37 02 	lds	r24, 0x0237	; 0x800237 <TimerFlag>
	cursor = 17;
	LCD_Cursor(cursor);
	
	while (1)
	{
		while(!TimerFlag) {};
 a72:	88 23       	and	r24, r24
 a74:	e1 f3       	breq	.-8      	; 0xa6e <main+0xfa>
 a76:	10 92 37 02 	sts	0x0237, r1	; 0x800237 <TimerFlag>
		TimerFlag = 0;
 a7a:	f8 01       	movw	r30, r16
 a7c:	84 81       	ldd	r24, Z+4	; 0x04
		if (ram_user[4] == 1 && ram_bot == 0) {
 a7e:	81 30       	cpi	r24, 0x01	; 1
 a80:	31 f4       	brne	.+12     	; 0xa8e <main+0x11a>
 a82:	80 91 32 02 	lds	r24, 0x0232	; 0x800232 <ram_bot>
 a86:	81 11       	cpse	r24, r1
 a88:	02 c0       	rjmp	.+4      	; 0xa8e <main+0x11a>
 a8a:	ee dd       	rcall	.-1060   	; 0x668 <login>
 a8c:	f0 cf       	rjmp	.-32     	; 0xa6e <main+0xfa>
			login();
 a8e:	99 dc       	rcall	.-1742   	; 0x3c2 <createAcc>
 a90:	ee cf       	rjmp	.-36     	; 0xa6e <main+0xfa>

00000a92 <__tablejump2__>:
	
	while (1)
	{
		while(!TimerFlag) {};
		TimerFlag = 0;
		if (ram_user[4] == 1 && ram_bot == 0) {
 a92:	ee 0f       	add	r30, r30
			login();
		}
		else {
			createAcc();
 a94:	ff 1f       	adc	r31, r31
 a96:	00 24       	eor	r0, r0
 a98:	00 1c       	adc	r0, r0
 a9a:	0b be       	out	0x3b, r0	; 59
 a9c:	07 90       	elpm	r0, Z+
 a9e:	f6 91       	elpm	r31, Z
 aa0:	e0 2d       	mov	r30, r0
 aa2:	09 94       	ijmp

00000aa4 <eeprom_read_byte>:
 aa4:	f9 99       	sbic	0x1f, 1	; 31
 aa6:	fe cf       	rjmp	.-4      	; 0xaa4 <eeprom_read_byte>
 aa8:	92 bd       	out	0x22, r25	; 34
 aaa:	81 bd       	out	0x21, r24	; 33
 aac:	f8 9a       	sbi	0x1f, 0	; 31
 aae:	99 27       	eor	r25, r25
 ab0:	80 b5       	in	r24, 0x20	; 32
 ab2:	08 95       	ret

00000ab4 <eeprom_update_byte>:
 ab4:	26 2f       	mov	r18, r22

00000ab6 <eeprom_update_r18>:
 ab6:	f9 99       	sbic	0x1f, 1	; 31
 ab8:	fe cf       	rjmp	.-4      	; 0xab6 <eeprom_update_r18>
 aba:	92 bd       	out	0x22, r25	; 34
 abc:	81 bd       	out	0x21, r24	; 33
 abe:	f8 9a       	sbi	0x1f, 0	; 31
 ac0:	01 97       	sbiw	r24, 0x01	; 1
 ac2:	00 b4       	in	r0, 0x20	; 32
 ac4:	02 16       	cp	r0, r18
 ac6:	39 f0       	breq	.+14     	; 0xad6 <eeprom_update_r18+0x20>
 ac8:	1f ba       	out	0x1f, r1	; 31
 aca:	20 bd       	out	0x20, r18	; 32
 acc:	0f b6       	in	r0, 0x3f	; 63
 ace:	f8 94       	cli
 ad0:	fa 9a       	sbi	0x1f, 2	; 31
 ad2:	f9 9a       	sbi	0x1f, 1	; 31
 ad4:	0f be       	out	0x3f, r0	; 63
 ad6:	08 95       	ret

00000ad8 <eeprom_write_byte>:
 ad8:	26 2f       	mov	r18, r22

00000ada <eeprom_write_r18>:
 ada:	f9 99       	sbic	0x1f, 1	; 31
 adc:	fe cf       	rjmp	.-4      	; 0xada <eeprom_write_r18>
 ade:	1f ba       	out	0x1f, r1	; 31
 ae0:	92 bd       	out	0x22, r25	; 34
 ae2:	81 bd       	out	0x21, r24	; 33
 ae4:	20 bd       	out	0x20, r18	; 32
 ae6:	0f b6       	in	r0, 0x3f	; 63
 ae8:	f8 94       	cli
 aea:	fa 9a       	sbi	0x1f, 2	; 31
 aec:	f9 9a       	sbi	0x1f, 1	; 31
 aee:	0f be       	out	0x3f, r0	; 63
 af0:	01 96       	adiw	r24, 0x01	; 1
 af2:	08 95       	ret

00000af4 <_exit>:
 af4:	f8 94       	cli

00000af6 <__stop_program>:
 af6:	ff cf       	rjmp	.-2      	; 0xaf6 <__stop_program>
